#!/usr/bin/env node

/*
 * Copyright 2016 Telefónica Investigación y Desarrollo, S.A.U
 *
 * This file is part of the Short Time Historic (STH) component
 *
 * STH is free software: you can redistribute it and/or
 * modify it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the License,
 * or (at your option) any later version.
 *
 * STH is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public
 * License along with STH.
 * If not, see http://www.gnu.org/licenses/.
 *
 * For those usages not covered by the GNU Affero General Public License
 * please contact with: [german.torodelvalle@telefonica.com]
 */

/* eslint-disable consistent-return */

const ROOT_PATH = require('app-root-path');
const async = require('async');
const commander = require('commander');
const sthConfig = require(ROOT_PATH + '/lib/configuration/sthConfiguration');
const sthDatabase = require(ROOT_PATH + '/lib/database/sthDatabase');
const sthDatabaseNameCodecTool = require(ROOT_PATH + '/lib/database/model/sthDatabaseNameCodecTool');
const sthLogger = require('logops');
const version = require(ROOT_PATH + '/package.json').version;

/**
 * Releases all the resources used by the application
 * @param  {Function} callback The callback
 */
function cleanResources(callback) {
    sthDatabase.closeConnection(callback);
}

/**
 * Exits the process releasing any used resources
 * @param err Error if any
 */
function exitGracefully(err) {
    if (err) {
        sthLogger.error(sthConfig.LOGGING_CONTEXT.DB_LOG, 'Exiting gracefully due to error: ', err);
    }
    cleanResources(function() {
        process.exit(err ? 1 : 0);
    });
}

// In case Control+C is clicked, exit gracefully
process.on('SIGINT', function() {
    return exitGracefully();
});

// In case of an uncaught exception exists gracefully
process.on('uncaughtException', function(exception) {
    return exitGracefully(exception);
});

/**
 * Prints a encoding/decoding analysis to the console
 * @param  {Object}   analysis The encoding/decoding analysis
 * @param  {Function} callback The callback
 */
function printEncodingAnalysis(analysis, callback) {
    let output =
        '========== ' +
        (commander.encode ? 'ENCODING' : 'DECODING') +
        ' ANALYSIS RESULTS (' +
        new Date() +
        ' ==========\n\n';
    if (commander.database) {
        output +=
            '  - ' +
            (commander.encode ? 'Encoding' : 'Decoding') +
            " process limited to database '" +
            commander.database +
            "'\n";
    }
    if (commander.collection) {
        output +=
            '  - ' +
            (commander.encode ? 'Encoding' : 'Decoding') +
            " process limited to collection '" +
            commander.collection +
            "'\n";
    }
    if (commander.database || commander.collection) {
        output += '\n';
    }
    const databaseNames = Object.getOwnPropertyNames(analysis);
    databaseNames.forEach(function(databaseName) {
        if (databaseName === analysis[databaseName].name) {
            output +=
                "  - Database '" + databaseName + "' will not be " + (commander.encode ? 'encoded' : 'decoded') + '\n';
        } else {
            output +=
                "  - Database '" +
                databaseName +
                "' will be " +
                (commander.encode ? 'encoded' : 'decoded') +
                " as '" +
                analysis[databaseName].name +
                "'\n";
        }
        if (
            analysis[databaseName].collections &&
            Object.getOwnPropertyNames(analysis[databaseName].collections).length
        ) {
            const collectionNames = Object.getOwnPropertyNames(analysis[databaseName].collections);
            collectionNames.forEach(function(collectionName) {
                if (collectionName === analysis[databaseName].collections[collectionName].name) {
                    output +=
                        "    - Collection '" +
                        collectionName +
                        "' will not be " +
                        (commander.encode ? 'encoded' : 'decoded') +
                        '\n';
                } else {
                    output +=
                        "    - Collection '" +
                        collectionName +
                        "' will be " +
                        (commander.encode ? 'encoded' : 'decoded') +
                        " as '" +
                        analysis[databaseName].collections[collectionName].name +
                        "'\n";
                }
            });
        }
    });
    if (!databaseNames.length) {
        output += '  - Nothing will be ' + (commander.encode ? 'encoded' : 'decoded') + '\n';
    }
    /* eslint-disable-next-line no-console */
    console.log('\n' + output);
    process.nextTick(callback);
}

/**
 * Command to generate an encoding/decoding analysis and print it to the console
 * @param  {Function} callback The callback
 */
function printEncodingAnalysisCommand(callback) {
    async.seq(
        async.apply(sthDatabaseNameCodecTool.getEncodingAnalysis, {
            encode: commander.encode,
            decode: commander.decode,
            database: commander.database,
            collection: commander.collection
        }),
        printEncodingAnalysis
    )(callback);
}

/**
 * Handler to be notified once the command to print an encoding/decoding analysis is completed
 * @param  {Object}  err The error (if any)
 */
function onPrintEncodingAnalysisCommand(err) {
    if (err) {
        sthLogger.error(sthConfig.LOGGING_CONTEXT.DB_LOG, 'Exiting gracefully due to error: ', err);
    }
    process.exit(err ? 1 : 0);
}

/**
 * Command to generate an encoding/decoding analysis and apply it renaming the corresponding databases and collections
 * @param  {Function} callback The callback
 */
function forceEncodeOrDecodeCommand(callback) {
    async.seq(
        async.apply(sthDatabaseNameCodecTool.getEncodingAnalysis, {
            encode: commander.encode,
            decode: commander.decode,
            database: commander.database,
            collection: commander.collection
        }),
        printEncodingAnalysis,
        async.apply(sthDatabaseNameCodecTool.encodeOrDecode, {
            encode: commander.encode,
            decode: commander.decode,
            database: commander.database,
            collection: commander.collection
        })
    )(callback);
}

/**
 * Handler to be notified once the command to apply an encoding/decoding analysis is completed
 * @param  {Object} err The error (if any)
 */
function onForceEncodeOrDecodeCommand(err) {
    if (err) {
        sthLogger.error(sthConfig.LOGGING_CONTEXT.DB_LOG, 'Exiting gracefully due to error: ', err);
    }
    sthLogger.info(
        sthConfig.LOGGING_CONTEXT.DB_LOG,
        (commander.encode ? 'Codification' : 'Decodification') + ' process successfully completed.'
    );
    process.exit(err ? 1 : 0);
}

/**
 * Executes the requested command
 */
function executeCommand() {
    if (!commander.encode && !commander.decode) {
        /* eslint-disable-next-line no-console */
        console.log('\nERROR: Either the -e (--encode) or the -d (--decode) options are mandatory');
        return commander.help();
    }
    if (commander.collection && !commander.database) {
        /* eslint-disable-next-line no-console */
        console.log('\nERROR: The -b (--database) option is mandatory if the -c (--collection) option is set');
        return commander.help();
    }
    if (commander.force) {
        forceEncodeOrDecodeCommand(onForceEncodeOrDecodeCommand);
    } else if (commander.encode || commander.decode) {
        printEncodingAnalysisCommand(onPrintEncodingAnalysisCommand);
    }
}

/* eslint-disable-next-line no-useless-concat */
commander
    .version(version)
    .option(
        '-e, --encode',
        'Shows a report regarding the result of the codification process if applied to databases ' +
            'and collections of a specific STH instance (either the -e or -d options are mandatory)'
    )
    .option(
        '-d, --decode',
        'Shows a report regarding the result of the decodification process if applied to databases ' +
            'and collections of a specific STH instance (either the -e or -d options are mandatory)'
    )
    .option(
        '-f, --force',
        'Forces the codification (-e) or decodification (-d) process and consequently the databases ' +
            'will be renamed'
    )
    .option('-b, --database <databaseName>', 'Limits the codification or decodification process to certain database')
    .option(
        '-c, --collection <collectionName>',
        'Limits the codification or decodification process to certain collection'
    )
    .parse(process.argv);

executeCommand();
