#!/usr/bin/env node

/*
 * Copyright 2016 Telefónica Investigación y Desarrollo, S.A.U
 *
 * This file is part of the Short Time Historic (STH) component
 *
 * STH is free software: you can redistribute it and/or
 * modify it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the License,
 * or (at your option) any later version.
 *
 * STH is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public
 * License along with STH.
 * If not, see http://www.gnu.org/licenses/.
 *
 * For those usages not covered by the GNU Affero General Public License
 * please contact with: [german.torodelvalle@telefonica.com]
 */

/* eslint-disable consistent-return */

const ROOT_PATH = require('app-root-path');
const async = require('async');
const commander = require('commander');
const sthConfig = require(ROOT_PATH + '/lib/configuration/sthConfiguration');
const sthDatabase = require(ROOT_PATH + '/lib/database/sthDatabase');
const sthDatabaseNameMapperTool = require(ROOT_PATH + '/lib/database/model/sthDatabaseNameMapperTool');
const sthLogger = require('logops');
const version = require(ROOT_PATH + '/package.json').version;

/**
 * Releases all the resources used by the application
 * @param  {Function} callback The callback
 */
function cleanResources(callback) {
    sthDatabase.closeConnection(callback);
}

/**
 * Exits the process releasing any used resources
 * @param err Error if any
 */
function exitGracefully(err) {
    if (err) {
        sthLogger.error(sthConfig.LOGGING_CONTEXT.DB_LOG, 'Exiting gracefully due to error: ', err);
    }
    cleanResources(function() {
        process.exit(err ? 1 : 0);
    });
}

// In case Control+C is clicked, exit gracefully
process.on('SIGINT', function() {
    return exitGracefully();
});

// In case of an uncaught exception exists gracefully
process.on('uncaughtException', function(exception) {
    return exitGracefully(exception);
});

/**
 * Prints a mapping/unmapping analysis to the console
 * @param  {Object}   analysis The mapping/unmapping analysis
 * @param  {Function} callback The callback
 */
function printMappingAnalysis(analysis, callback) {
    let output =
        '========== ' +
        (commander.map ? 'MAPPING' : 'UNMAPPING') +
        ' ANALYSIS RESULTS (' +
        new Date() +
        ' ==========\n\n';
    if (commander.database) {
        output +=
            '  - ' +
            (commander.map ? 'Mapping' : 'Unmapping') +
            " process limited to database '" +
            commander.database +
            "'\n";
    }
    if (commander.collection) {
        output +=
            '  - ' +
            (commander.map ? 'Mapping' : 'Unmapping') +
            " process limited to collection '" +
            commander.collection +
            "'\n";
    }
    if (commander.database || commander.collection) {
        output += '\n';
    }
    const databaseNames = Object.getOwnPropertyNames(analysis);
    databaseNames.forEach(function(databaseName) {
        if (databaseName === analysis[databaseName].name) {
            output +=
                "  - Database '" + databaseName + "' will not be " + (commander.map ? 'mapped' : 'unmapped') + '\n';
        } else {
            output +=
                "  - Database '" +
                databaseName +
                "' will be " +
                (commander.map ? 'mapped' : 'unmapped') +
                " as '" +
                analysis[databaseName].name +
                "'\n";
        }
        if (
            analysis[databaseName].collections &&
            Object.getOwnPropertyNames(analysis[databaseName].collections).length
        ) {
            const collectionNames = Object.getOwnPropertyNames(analysis[databaseName].collections);
            collectionNames.forEach(function(collectionName) {
                if (collectionName === analysis[databaseName].collections[collectionName].name) {
                    output +=
                        "    - Collection '" +
                        collectionName +
                        "' will not be " +
                        (commander.map ? 'mapped' : 'unmapped') +
                        '\n';
                } else {
                    output +=
                        "    - Collection '" +
                        collectionName +
                        "' will be " +
                        (commander.map ? 'mapped' : 'unmapped') +
                        " as '" +
                        analysis[databaseName].collections[collectionName].name +
                        "'\n";
                }
            });
        }
    });
    if (!databaseNames.length) {
        output += '  - Nothing will be ' + (commander.map ? 'mapped' : 'unmapped') + '\n';
    }
    /* eslint-disable-next-line no-console */
    console.log('\n' + output);
    process.nextTick(callback);
}

/**
 * Command to generate an mapping/unmapping analysis and print it to the console
 * @param  {Function} callback The callback
 */
function printMappingAnalysisCommand(callback) {
    async.seq(
        async.apply(sthDatabaseNameMapperTool.getMappingAnalysis, {
            map: commander.map,
            unmap: commander.unmap,
            database: commander.database,
            collection: commander.collection
        }),
        printMappingAnalysis
    )(callback);
}

/**
 * Handler to be notified once the command to print an mapping/unmapping analysis is completed
 * @param  {Object}  err The error (if any)
 */
function onPrintMappingAnalysisCommand(err) {
    if (err) {
        sthLogger.error(sthConfig.LOGGING_CONTEXT.DB_LOG, 'Exiting gracefully due to error: ', err);
    }
    process.exit(err ? 1 : 0);
}

/**
 * Command to generate an mapping/unmapping analysis and apply it renaming the corresponding databases and collections
 * @param  {Function} callback The callback
 */
function forceMapOrUnmapCommand(callback) {
    async.seq(
        async.apply(sthDatabaseNameMapperTool.getMappingAnalysis, {
            map: commander.map,
            unmap: commander.unmap,
            database: commander.database,
            collection: commander.collection
        }),
        printMappingAnalysis,
        async.apply(sthDatabaseNameMapperTool.mapOrUnmap, {
            map: commander.map,
            unmap: commander.unmap,
            database: commander.database,
            collection: commander.collection
        })
    )(callback);
}

/**
 * Handler to be notified once the command to apply an mapping/unmapping analysis is completed
 * @param  {Object} err The error (if any)
 */
function onForceMapOrUnmapCommand(err) {
    if (err) {
        sthLogger.error(sthConfig.LOGGING_CONTEXT.DB_LOG, 'Exiting gracefully due to error: ', err);
    }
    sthLogger.info(
        sthConfig.LOGGING_CONTEXT.DB_LOG,
        (commander.map ? 'Mapping' : 'Unmapping') + ' process successfully completed.'
    );
    process.exit(err ? 1 : 0);
}

/**
 * Executes the requested command
 */
function executeCommand() {
    if (!commander.map && !commander.unmap) {
        /* eslint-disable-next-line no-console */
        console.log('\nERROR: Either the -m (--map) or the -u (--unmap) options are mandatory');
        return commander.help();
    }
    if (commander.collection && !commander.database) {
        /* eslint-disable-next-line no-console */
        console.log('\nERROR: The -b (--database) option is mandatory if the -c (--collection) option is set');
        return commander.help();
    }
    if (commander.force) {
        forceMapOrUnmapCommand(onForceMapOrUnmapCommand);
    } else if (commander.map || commander.unmap) {
        printMappingAnalysisCommand(onPrintMappingAnalysisCommand);
    }
}

commander
    .version(version)
    .option(
        '-m, --map',
        'Shows a report regarding the result of the mapping process if applied to databases ' +
            'and collections of a specific STH instance (either the -m or -u options are mandatory)'
    )
    .option(
        '-u, --unmap',
        'Shows a report regarding the result of the unmapping process if applied to databases ' +
            'and collections of a specific STH instance (either the -e or -d options are mandatory)'
    )
    .option(
        '-f, --force',
        'Forces the mapping (-m) or unmapping (-u) process and consequently the databases will be renamed'
    )
    .option('-b, --database <databaseName>', 'Limits the mapping or unmapping process to certain database')
    .option('-c, --collection <collectionName>', 'Limits the mapping or unmapping process to certain collection')
    .parse(process.argv);

executeCommand();
